#include <algorithm>
#include <iostream>
#include <map>
#include <vector>
#include <set>
#include <string>
#include <queue>
#include <cmath>

#pragma GCC optimize("Ofast,no-stack-protector")
#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native")
#pragma GCC optimize("unroll-loops")
#pragma GCC optimize("fast-math")
#pragma GCC optimize("section-anchors")
#pragma GCC optimize("profile-values,profile-reorder-functions,tracer")
#pragma GCC optimize("vpt")
#pragma GCC optimize("rename-registers")
#pragma GCC optimize("move-loop-invariants")
#pragma GCC optimize("unswitch-loops")
#pragma GCC optimize("function-sections")
#pragma GCC optimize("data-sections")
#pragma GCC optimize("branch-target-load-optimize")
#pragma GCC optimize("branch-target-load-optimize2")
#pragma GCC optimize("btr-bb-exclusive")

# define M_PI 3.14159265358979323846  /* pi */
const double ACC = 1e-7;

long double scal(long double x0, long double y0, long double x1, long double y1) {
    return (x0 * x1 + y0 * y1);
}
long double vect(long double x0, long double y0, long double x1, long double y1) {
    return (x0 * y1 - y0 * x1);
}
long double len(long double x0, long double y0) {
    return std::sqrt(x0 * x0 + y0 * y0);
}
long double triag_area(long double x0, long double y0, long double x1, long double y1) {
    return std::abs(vect(x0, y0, x1, y1) / 2);
}
bool is_peer(double a, double b) {
    if (abs(a - b) < 1e-6) return true;
    else return false;
}
bool is_parall(long double a1, long double b1, long double c1,
    long double a2, long double b2, long double c2) {
    if ((is_peer(a1, 0) && (is_peer(a2, 0))) && (!is_peer(b1, 0) || !is_peer(b2, 0))) return true;
    if ((is_peer(b1, 0) && (is_peer(b2, 0))) && (!is_peer(a1, 0) || !is_peer(a2, 0))) return true;
    if ((is_peer(a1, 0) && !(is_peer(a2, 0))) || (!is_peer(a1, 0) && (is_peer(a2, 0)))) return false;
    if ((is_peer(b1, 0) && !(is_peer(b2, 0))) || (!is_peer(b1, 0) && (is_peer(b2, 0)))) return false;
    long double k = double(double(a1) / double(a2));
    if (is_peer(a1, k * a2) && is_peer(b1, k * b2)) return true;
    else return false;
}
std::pair<long double, long double> inters(long double a1, long double b1, long double c1,
    long double a2, long double b2, long double c2) {
    long double del = a1 * b2 - a2 * b1;
    long double del1 = -c1 * b2 + c2 * b1;
    long double del2 = -a1 * c2 + a2 * c1;
    return std::make_pair(double(double(del1) / double(del)), double(double(del2) / double(del)));
}
long double find_dist(long double a1, long double b1, long double c1,
    long double x1, long double y1) {
    return double(double(std::abs(a1 * x1 + b1 * y1 + c1)) / double(std::sqrt(a1 * a1 + b1 * b1)));
}
const long double error = 1e-6;
bool is_here(long long a, long long b, long double c) {
    return (std::min(a, b) <= c + error) && (c <= std::max(a, b) + error);
}
bool is_on_another(long long a, long long b, long long c, long long d) {
    return std::max(std::min(a, b), std::min(c, d)) <= std::min(std::max(a, b), std::max(c, d));
}
struct point {
    long long x;
    long long y;
    point(long long x, long long y) :x(x), y(y) {}
    point(const point& p) {
        x = p.x;
        y = p.y;
    }
    point& operator=(point p) {
        x = p.x;
        y = p.y;
        return *this;
    }
    
};
bool operator <(point& a, point& b) {
    if (a.x < b.x) return a.x < b.x;
    else if (a.x == b.x) return a.y <= b.y;
    else return false;
}
bool operator == (point& p, point & q) {
    return p.x == q.x && p.y == q.y;
}
point operator+(point& p, point& q) {
    point x(p.x + q.x, p.y + q.y);
    return x;
}
std::string is_convex(std::vector<point>& shape) {
    int j = 0;
    bool is_bad = 0;
    bool is_lower_zero = 0;
    while (1) {
        if (j == 0 && is_bad) {
            return "NO";
        }
        long long v1x;
        long long v1y;
        long long v2x;
        long long v2y;
        if (j == shape.size() - 2) {
            v1x = shape[j + 1].x - shape[j].x;
            v1y = shape[j + 1].y - shape[j].y;
            v2x = shape[0].x - shape[j + 1].x;
            v2y = shape[0].y - shape[j + 1].y;
        }
        else if (j == shape.size() - 1) {
            v1x = shape[0].x - shape[j].x;
            v1y = shape[0].y - shape[j].y;
            v2x = shape[1].x - shape[0].x;
            v2y = shape[1].y - shape[0].y;
        }
        else {
            v1x = shape[j + 1].x - shape[j].x;
            v1y = shape[j + 1].y - shape[j].y;
            v2x = shape[j + 2].x - shape[j + 1].x;
            v2y = shape[j + 2].y - shape[j + 1].y;
        }
        if (vect(v1x, v1y, v2x, v2y) == 0) {
            j++;
            is_bad = 1;
        }
        else {
            is_lower_zero = vect(v1x, v1y, v2x, v2y) < 0 ? 1 : 0;
            break;
        }
    }
    bool is_convex = 1;
    for (int i = 1; i < shape.size(); i++) {
        long long v1x;
        long long v1y;
        long long v2x;
        long long v2y;
        if (i == shape.size() - 2) {
            v1x = shape[i + 1].x - shape[i].x;
            v1y = shape[i + 1].y - shape[i].y;
            v2x = shape[0].x - shape[i + 1].x;
            v2y = shape[0].y - shape[i + 1].y;
        }
        else if (i == shape.size() - 1) {
            v1x = shape[0].x - shape[i].x;
            v1y = shape[0].y - shape[i].y;
            v2x = shape[1].x - shape[0].x;
            v2y = shape[1].y - shape[0].y;
        }
        else {
            v1x = shape[i + 1].x - shape[i].x;
            v1y = shape[i + 1].y - shape[i].y;
            v2x = shape[i + 2].x - shape[i + 1].x;
            v2y = shape[i + 2].y - shape[i + 1].y;
        }
        if (is_lower_zero && vect(v1x, v1y, v2x, v2y) > 0) {
            is_convex = 0;
            break;
        }
        if (!is_lower_zero && vect(v1x, v1y, v2x, v2y) < 0) {
            is_convex = 0;
            break;
        }
    }
    return is_convex ? "YES" : "NO";
}
bool is_intersect(long long x0_1, long long y0_1, long long x0_2, long long y0_2,
    long long x1_1, long long y1_1, long long x1_2, long long y1_2) {
    if ((x0_1 == x0_2 && y0_1 == y0_2) && (x1_1 == x1_2 && y1_1 == y1_2)) {
        if ((x0_1 == x1_1 && y0_1 == y1_1)) {
            return 1;
        }
        else {
            return 0;
        }
    }
    else if ((x0_1 == x0_2 && y0_1 == y0_2)) {
        if (is_here(x1_1, x1_2, x0_1) && is_here(y1_1, y1_2, y0_1)) {
            return 1;
        }
        else {
            return 0;
        }
    }
    else if ((x1_1 == x1_2 && y1_1 == y1_2)) {
        if (is_here(x0_1, x0_2, x1_1) && is_here(y0_1, y0_2, y1_1)) {
            return 1;
        }
        else {
            return 0;
        }
    }
    long long a1 = y0_1 - y0_2;
    long long b1 = x0_2 - x0_1;
    long long c1 = x0_1 * y0_2 - x0_2 * y0_1;
    long long a2 = y1_1 - y1_2;
    long long b2 = x1_2 - x1_1;
    long long c2 = x1_1 * y1_2 - x1_2 * y1_1;
    if (!is_parall(a1, b1, c1, a2, b2, c2)) {
        std::pair<long double, long double> inter = inters(a1, b1, c1, a2, b2, c2);
        if (is_here(x0_1, x0_2, inter.first) && is_here(x1_1, x1_2, inter.first) &&
            is_here(y0_1, y0_2, inter.second) && is_here(y1_1, y1_2, inter.second)) {
            return 1;
        }
        else {
            return 0;
        }
        return 0;
    }
    else {
        if ((a1 * c2 - a2 * c1) == 0 && (b1 * c2 - b2 * c1) == 0 &&
            is_on_another(x0_1, x0_2, x1_1, x1_2) &&
            is_on_another(y0_1, y0_2, y1_1, y1_2)) {
            return 1;
        }
        else {
            return 0;
        }
    }
}
bool is_on_otr(point p, point p1, point p2) {
    if ((p.x - p1.x) * (p2.y - p1.y) == (p2.x - p1.x) * (p.y - p1.y)) {
        if (std::min(p1.y, p2.y) <= p.y && (std::max(p1.y, p2.y) >= p.y) &&
            std::min(p1.x, p2.x) <= p.x && std::max(p1.x, p2.x) >= p.x) {
            return 1;
        }
    }
    return 0;
}
std::string is_in_shape(std::vector<point>& shape, point& p) {
    bool is_in_shape = 0;
    for (int i = 0; i < shape.size(); i++) {
        int j = (i + 1) % shape.size();
        if (is_on_otr(p, shape[i], shape[j])) return "YES\n";
    }
    long long x = 10e10;
    point B(x, p.y + 1);
    for (int i = 0; i < shape.size(); i++) {
        int j = (i + 1) % shape.size();
        if (is_intersect(p.x, p.y, B.x, B.y, shape[i].x, shape[i].y, shape[j].x, shape[j].y))
            is_in_shape = !is_in_shape;
    }
    return is_in_shape ? "YES\n" : "NO\n";
}
bool comp(point a, point b) {
    return a < b || a == b;
}
std::vector<point> convex_hull(std::vector<point>& shape, int ind) {
    std::sort(shape.begin(), shape.end(), comp);
    std::vector<point> upper;
    std::vector<point> lower;
    upper.push_back(shape[0]);
    lower.push_back(shape[0]);
    for (int i = 1; i < shape.size(); i++) {
        if (i + 1 == shape.size() || vect(shape[i].x - shape[0].x,
            shape[i].y - shape[0].y,
            shape[shape.size() - 1].x - shape[i].x,
            shape[shape.size() - 1].y - shape[i].y) > 0) {
            while (lower.size() >= 2 &&
                vect(lower[lower.size() - 1].x - lower[lower.size() - 2].x,
                    lower[lower.size() - 1].y - lower[lower.size() - 2].y,
                    shape[i].x - lower[lower.size() - 1].x,
                    shape[i].y - lower[lower.size() - 1].y) <= 0) {
                lower.pop_back();
            }
            lower.push_back(shape[i]);
        }
        if (i + 1 == shape.size() || vect(shape[i].x - shape[0].x,
            shape[i].y - shape[0].y,
            shape[shape.size() - 1].x - shape[i].x,
            shape[shape.size() - 1].y - shape[i].y) < 0) {
            while (upper.size() >= 2 &&
                vect(upper[upper.size() - 1].x - upper[upper.size() - 2].x,
                    upper[upper.size() - 1].y - upper[upper.size() - 2].y,
                    shape[i].x - upper[upper.size() - 1].x,
                    shape[i].y - upper[upper.size() - 1].y) >= 0) {
                upper.pop_back();
            }
            upper.push_back(shape[i]);
        }
    }
    std::vector<point> ans;
    for (int i = 0; i < lower.size(); i++)
        ans.push_back(lower[i]);
    for (int i = upper.size() - 2; i > 0; i--)
        ans.push_back(upper[i]);
    return ans;
}

struct rect {
    point p;
    long long a;
    rect(point p, long long a) :p(p), a(a) {}
};


struct line {
    long long k, m;
    long long a, b, c;
    line() :k(0), m(0) { a = 0; b = 0; c = 0; }
    line(point& p, point& q) {
        if (p.x == q.x && p.y == q.y) throw;
        a = p.y - q.y;
        b = q.x - p.x;
        c = p.x * q.y - q.x * p.y;
        k = 0;
        m = 0;
    }
    long long get(long long x) {
        return (-a * x - c) / b;
    }
    line(long long k, long long b) :k(k), b(b) {}
    int intersect(line& l) {
        if (k > l.k) {
            long long int_point = (l.b - b) / (k - l.k);
            long long tmp = int_point - 1;
            return l.b < b ? tmp : int_point;
        }
        else {
            long long int_point = (b - l.b) / (l.k - k);
            long long tmp = int_point - 1;
            return b < l.b ? tmp : int_point;
        }
    }
};

struct up_hull {
    std::vector<long long> inters_points;
    std::vector<line> lines;
    up_hull() {
        inters_points = std::vector<long long>();
        lines = std::vector<line>();
    }
    int get(long long ptr) {
        if (inters_points.size() == 0) return 0;
        int pos = std::lower_bound(inters_points.begin(), inters_points.end(), ptr) -
            inters_points.begin() - 1;
        //pos--;
        return lines[pos].k * ptr + lines[pos].b;
    }
    void add(line nwl) {
        while (lines.size() > 0 &&
            (lines.back().k * inters_points.back() + lines.back().b >
                nwl.k * inters_points.back() + nwl.b)) {
            lines.pop_back();
            inters_points.pop_back();
        }

        inters_points.push_back(lines.size() == 0 ?
            -10e9 : lines.back().intersect(nwl));
        if (inters_points.size() > 2 && inters_points.back() == inters_points[inters_points.size() - 2]) {
            inters_points.pop_back();
            lines.pop_back();
        }
        lines.push_back(nwl);
    }
};

long double dist_sq(line l, point p) {
    return (l.a * p.x + l.b * p.y + l.c) * (l.a * p.x + l.b * p.y + l.c) / (l.a * l.a + l.b * l.b);
}
long long scal(point& p, point& q) {
    return p.x * q.x + p.y * q.y;
}
long long find_mx(std::vector<point>& upper, point p) {
    int l = -1;
    int r = upper.size() - 1;
    while (r - l > 1) {
        int m = (r + l) >> 1;
        long long x = scal(upper[m], p);
        long long y = scal(upper[m + 1], p);
        if (x < y) l = m;
        else if (x > y) r = m;
        else return x;
    }
    long long mx = -1;
    if (l == -1) l++;
    while (l < r+1) {
        mx = std::max(mx, scal(upper[l], p));
        l++;
    }
    return mx;
}

std::vector<point> sum_mink(std::vector<point>& t1, std::vector<point>& t2) {
    std::vector<point> res;
    res.push_back(t1[0] + t2[0]);
    int i = 0;
    int j = 0;
    while(i < t1.size() || j < t2.size()) {
        int tmpi = (i+1) % t1.size();
        int tmpj = (j+1) % t2.size();
        if (!(i < t1.size())) {
            if (j + 1 == t2.size()) return res;
            point p(t2[tmpj].x - t2[j].x, t2[tmpj].y - t2[j].y);
            res.push_back(p + res.back());
            j++;
            continue;
        }
        if (!(j < t2.size())) {
            if (i + 1 == t1.size()) return res;
            point p(t1[tmpi].x - t1[i].x, t1[tmpi].y - t1[i].y);
            res.push_back(res.back() + p);
            i++;
            continue;
        }
        if (vect(t1[tmpi].x - t1[i].x, t1[tmpi].y - t1[i].y, t2[tmpj].x - t2[j].x, t2[tmpj].y - t2[j].y) > 0) {
            point p(t1[tmpi].x - t1[i].x, t1[tmpi].y - t1[i].y);
            res.push_back(res.back() + p);
            i++;
        }
        else if(vect(t1[tmpi].x - t1[i].x, t1[tmpi].y - t1[i].y, t2[tmpj].x - t2[j].x, t2[tmpj].y - t2[j].y) < 0){
            point p(t2[tmpj].x - t2[j].x, t2[tmpj].y - t2[j].y);
            res.push_back(p + res.back());
            j++;
        }
        else {
            if (i + 1 == t1.size() && j + 1 == t2.size()) return res;
            point p1(t1[tmpi].x - t1[i].x, t1[tmpi].y - t1[i].y);
            point p2(t2[tmpj].x - t2[j].x, t2[tmpj].y - t2[j].y);
            point p3(res.back().x + p1.x, res.back().y + p1.y);
            res.push_back(p3 + p2);
            i++;
            j++;

        }
    }
    return res;
}

long long is_in_triang(point p1, point p2, point p3) {
    long long res = (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x);
    return res;
}
const long long BAD = 10e9;
struct ang {
    long long x, y;
    ang(point p) {
        if (p.y == 0) {
            if (p.x < 0) {
                x = -BAD;
                y = 0;
            }
            else {
                x = BAD;
                y = 0;
            }
        }
        else {
            x = p.x;
            y = p.y;
        }
    }
};
bool operator<(const ang& a, const ang& b) {
    if (a.x == b.x) return a.y < b.y;
    else return (a.y * b.x < a.x* b.y);
}
bool operator==(ang& a1, ang& a2) {
    return a1.x == a2.x && a1.y == a2.y;
}
point operator-(point& p, point& q) {
    point cp(p.x - q.x, p.y - q.y);
    return cp;
}
bool is_in_good_shape(std::vector<ang>& angles, point& p, point& zero, std::vector<point>& minks) {
    bool is_good = 0;
    if (p.x < zero.x) return 0;
    if (p == zero) return 1;
    ang point_ang(p - zero);
    auto fn_smt = std::upper_bound(angles.begin(), angles.end(), point_ang);
    if (point_ang == angles[angles.size() - 1]) fn_smt = angles.end() - 1;
    if (fn_smt == angles.end() || fn_smt == angles.begin()) return 0;
    int ind = fn_smt - angles.begin();
    if (is_in_triang(minks[ind], minks[ind + 1], p) >= 0) return 1;
    return 0;
}


int main() {
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);
    std::cout.tie(0);
    std::cout.precision(9);
    long long n;
    std::vector<point> town1;
    std::vector<point> town2;
    std::vector<point> town3;
    int zero1 = -1;
    int zero2 = -1;
    int zero3 = -1;
    point zero_1(10e8, 10e8);
    point zero_2(10e8, 10e8);
    point zero_3(10e8, 10e8);
    std::cin >> n;
    for (int j = 0; j < n; j++) {
        long long x, y;
        std::cin >> x >> y;
        town1.push_back(point(x, y));
        if (town1.back() < zero_1) {
            zero1 = j;
            zero_1 = town1.back();
        }
    }
    std::cin >> n;
    for (int j = 0; j < n; j++) {
        long long x, y;
        std::cin >> x >> y;
        town2.push_back(point(x, y));
        if (town2.back() < zero_2) {
            zero2 = j;
            zero_2 = town2.back();
        }
    }
    std::cin >> n;
    for (int j = 0; j < n; j++) {
        long long x, y;
        std::cin >> x >> y;
        town3.push_back(point(x, y));
        if (town3.back() < zero_3) {
            zero3 = j;
            zero_3 = town3.back();
        }
    }
    std::rotate(town1.begin(), town1.begin() + zero1, town1.end());
    std::rotate(town2.begin(), town2.begin() + zero2, town2.end());
    std::rotate(town3.begin(), town3.begin() + zero3, town3.end());
    std::vector<point> minks = sum_mink(town1, town2);
    minks = sum_mink(minks, town3);
    std::vector<ang> angles;
    for (int i = 1; i < minks.size(); i++) {
        angles.push_back(ang(minks[i] - minks[0]));
    }
    int q;
    std::cin >> q;
    for (int i = 0; i < q; i++) {
        long long x, y;
        std::cin >> x >> y;
        x *= 3;
        y *= 3;
        point p(x, y);
        std::string ans = is_in_good_shape(angles, p, minks[0], minks) ? "YES\n" : "NO\n";
        std::cout << ans;
    }
}
