#include <iostream>
#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>
#include <string>
class BigInteger {
	static const int base = 10000;
	std::vector<int> digits;
	bool sign = false;

public:

	friend BigInteger operator+(const BigInteger& b_left, const BigInteger& b_right);
	friend BigInteger operator-(const BigInteger& b_left, const BigInteger& b_right);
	friend BigInteger operator*(const BigInteger& b_left, const BigInteger& b_right);

	bool operator==(const BigInteger&) const;
	bool operator!=(const BigInteger&) const;
	bool operator<(const BigInteger&) const;
	bool operator>(const BigInteger&) const;
	bool operator<=(const BigInteger&) const;
	bool operator>=(const BigInteger&) const;

	BigInteger& operator+=(const BigInteger&);
	BigInteger& operator-=(const BigInteger&);
	BigInteger& operator*=(const BigInteger&);
	BigInteger& operator/=(const BigInteger&);

	BigInteger& operator++();
	BigInteger operator++(int);
	BigInteger& operator--();
	BigInteger operator--(int);

	BigInteger();
	BigInteger(std::string);
	BigInteger(int);
	BigInteger(const BigInteger&);
	BigInteger(const char*);

	operator std::string();
	explicit operator bool();

	BigInteger operator-() const;

	void get_r();
	void remove_leading_zeros();
	std::string toString() const;

	BigInteger& ChangeSign(BigInteger& b) {
		if (b == 0) return b;
		b.sign = !(b.sign);
		return b;
	}
	bool is_even() const {
		return (digits[0] % 2 == 0);
	}
	friend std::ostream& operator <<(std::ostream&, const BigInteger&);
	friend std::istream& operator>>(std::istream&, BigInteger&);
	void multiply_on_10000(int a) {
		if (digits.size() == 0) {
			digits.push_back(0);
		}
		digits.resize(digits.size() + a, 0);
		for (int j = digits.size() - 1; j >= a; --j) {
			digits[j] = digits[j - a];
		}
		for (int i = 0; i < a; ++i) digits[i] = 0;


	}
};

//--------------------------КОНСТРУКТОРЫ---------------------------------------------------------------------------
BigInteger::BigInteger() {
	digits.push_back(0);
	sign = 0;
}
BigInteger::BigInteger(int i) {
	if (i < 0) {
		sign = 1;
		i = -i;
	}
	else if (i == 0) {
		digits.push_back(0);
		sign = 0;
	}
	while (i > 0) {
		digits.push_back(i % base);
		i /= base;
	}
	this->remove_leading_zeros();
}
BigInteger::BigInteger(const BigInteger& b) {
	digits.resize(b.digits.size());
	sign = b.sign;
	digits = b.digits;
}
BigInteger::BigInteger(std::string s) {
	if (s.length() == 0) {
		digits.push_back(0);
		this->sign = 0;
	}
	else {
		if (s[0] == '-') {
			s = s.substr(1);
			this->sign = 1;
		}
		else {
			this->sign = 0;
		}
		for (int i = s.length() - log(base); i > -log(base) - 1; i -= log(base)) {
			if (i < 0) {
				this->digits.push_back(atoi(s.substr(0, log(base) + i).c_str()));
			}
			else {
				this->digits.push_back(atoi(s.substr(i, log(base)).c_str()));
			}
		}
	}
	this->remove_leading_zeros();
}
BigInteger::BigInteger(const char* x) :BigInteger(std::string(x)) {}

//--------------------------ПРОЧЕЕ----------------------------------------------------------------------------------
void BigInteger::remove_leading_zeros() {
	while (this->digits.size() > 1 && this->digits.back() == 0) {
		this->digits.pop_back();
	}
	if (this->digits.size() == 1 && this->digits[0] == 0) {
		this->sign = 0;
	}
}
BigInteger BigInteger::operator-() const {
	BigInteger copy = *this;
	if (copy == 0) return copy;
	else {
		copy.sign = !(copy.sign);
		return copy;
	}
}
void BigInteger::get_r() {
	// перенос на разряд вперед, нужно в деление
	if (digits.size() == 0) {
		digits.push_back(0);
		return;
	}
	digits.push_back(digits[digits.size() - 1]);
	for (int i = static_cast<int>(digits.size()) - 2; i > 0; --i) {
		digits[i] = digits[i - 1];
	}
	digits[0] = 0;
}
std::string BigInteger::toString() const {
	std::string ans;
	if (sign) ans += "-";
	ans += std::to_string(digits[digits.size() - 1]);
	for (int i = digits.size() - 2; i >= 0; --i) {
		if (digits[i] < 10) ans += "000";
		else if (digits[i] < 100) ans += "00";
		else if (digits[i] < 1000) ans += "0";
		ans += std::to_string(digits[i]);

	}
	return ans;
}

//-------------------------ЛОГИЧЕСКИЕ ОПЕРАЦИИ----------------------------------------------------------------------
bool BigInteger::operator==(const BigInteger& b_right) const {
	if (digits.size() != b_right.digits.size()) return false;
	if (digits.empty() == 1 && b_right.digits.empty() == 1) return true;
	if (sign != b_right.sign) return false;
	for (int i = 0; i < static_cast<int>(digits.size()); ++i) {
		if (b_right.digits[i] != digits[i]) return false;
	}
	return true;
}
bool BigInteger::operator!=(const BigInteger& b_right) const {
	if (*this == b_right) return false;
	else return true;
}
bool BigInteger::operator<(const BigInteger& b_right) const {
	if (*this == b_right) return false;
	if (sign) {
		if (b_right.sign) return ((-b_right) < (-*this));
		else return true;
	}
	else if (b_right.sign) return false;
	else {
		if (digits.size() != b_right.digits.size()) {
			return digits.size() < b_right.digits.size();
		}
		else {
			for (int i = static_cast<int>(digits.size() - 1); i >= 0; --i) {
				if (digits[i] != b_right.digits[i]) return digits[i] < b_right.digits[i];
			}
			return false;
		}
	}
}
bool BigInteger::operator>(const BigInteger& b_right) const {
	if (*this == b_right || *this < b_right) return false;
	else return true;
}
bool BigInteger::operator <=(const BigInteger& b_right) const {
	if (*this < b_right || *this == b_right) return true;
	else return false;
}
bool BigInteger::operator>=(const BigInteger& b_right) const {
	if (*this == b_right || *this > b_right) return true;
	else return false;
}

//-------------------------СОСТАВНОЕ ПРИСВАИВАНИЕ-------------------------------------------------------------------
BigInteger& BigInteger::operator+=(const BigInteger& b) {
	// меняю знаки, если оба не + +
	if (sign) {
		if (b.sign) {
			return ChangeSign(ChangeSign(*this) += (-b));
		}
		else {
			return ChangeSign(ChangeSign(*this) -= b);
		}
	}
	else if (b.sign) return (*this -= (-b));
	else {
		int transfer = 0;
		for (size_t i = 0; i < std::max(digits.size(), b.digits.size()) || transfer != 0; ++i) {
			if (i == digits.size()) digits.push_back(0);
			digits[i] += transfer + (i < b.digits.size() ? b.digits[i] : 0);
			transfer = digits[i] >= base;
			if (transfer != 0) digits[i] -= base;
		}
		return *this;
	}
}
BigInteger& BigInteger::operator-=(const BigInteger& b) {
	if (sign) {
		if (b.sign) return ChangeSign(ChangeSign(*this) -= (-b));
		else return ChangeSign(ChangeSign(*this) += (b));
	}
	else if (b.sign) {
		return *this += -b;
	}
	else {
		if (*this < b) {
			BigInteger temp = *this;
			*this = b;
			return ChangeSign((*this -= temp));
		}
		else {
			int transfer = 0;
			for (size_t i = 0; i < b.digits.size() || transfer != 0; ++i) {
				digits[i] -= transfer + (i < b.digits.size() ? b.digits[i] : 0);
				transfer = digits[i] < 0;
				if (transfer != 0) digits[i] += base;
			}
			this->remove_leading_zeros();
			return *this;
		}
	}
}
BigInteger& BigInteger::operator*=(const BigInteger& b) {
	BigInteger result;
	result.digits.resize(digits.size() + b.digits.size());
	for (int i = 0; i < static_cast<int>(digits.size()); ++i) {
		int transfer = 0;
		for (int j = 0; j < static_cast<int>(b.digits.size()) || transfer != 0; ++j) {
			int res;
			if (j < static_cast<int>(b.digits.size())) res = result.digits[i + j] + digits[i] * b.digits[j] + transfer;
			else  res = transfer;
			result.digits[i + j] = res % base;
			transfer = res / base;
		}
	}
	result.sign = (sign != b.sign);
	result.remove_leading_zeros();
	*this = result;
	return *this;
}
BigInteger& BigInteger::operator/=(const BigInteger& b) {
	BigInteger big = b;
	BigInteger copy = *this;
	digits.clear();
	big.sign = 0;
	BigInteger current = 0;
	digits.resize(copy.digits.size());
	for (int i = static_cast<int>(digits.size()) - 1; i >= 0; --i) {
		current.get_r();
		current.digits[0] = copy.digits[i];
		current.remove_leading_zeros();
		int left = 0, right = base;
		int temp = 0;
		while (right >= left) {
			int middle = (left + right) / 2;
			BigInteger turn = big * BigInteger(middle);
			if (turn <= current) {
				temp = middle;
				left = middle + 1;
			}
			else right = middle - 1;
		}
		BigInteger turn = big * BigInteger(left);
		if (turn <= current) temp = left;
		digits[i] = temp;
		current -= big * BigInteger(temp);
	}
	sign = (sign != b.sign);
	remove_leading_zeros();
	return *this;
}

//-------------------------ОСНОВНЫЕ ОПЕРАЦИИ-------------------------------------------------------------------------
BigInteger operator+(const BigInteger& b_left, const BigInteger& b_right) {
	BigInteger copy = b_left;
	copy += b_right;
	return copy;
}
BigInteger operator-(const BigInteger& b_left, const BigInteger& b_right) {
	BigInteger copy = b_left;
	copy -= b_right;
	return copy;
}
BigInteger operator*(const BigInteger& b_left, const BigInteger& b_right) {
	BigInteger copy = b_left;
	copy *= b_right;
	return copy;
}

//-------------------------ИНКРЕМЕНТЫ И ДЕКРЕМЕНТЫ--------------------------------------------------------------------
BigInteger& BigInteger::operator++() {
	*this += 1;
	return *this;
}
BigInteger BigInteger::operator++(int) {
	BigInteger copy = *this;
	*this += 1;
	return copy;
}
BigInteger& BigInteger::operator--() {
	*this -= 1;
	return *this;
}
BigInteger BigInteger::operator--(int) {
	BigInteger copy = *this;
	*this -= 1;
	return copy;
}

//-------------------------ВВОД И ВЫВОД-------------------------------------------------------------------------------
std::ostream& operator <<(std::ostream& out, const BigInteger& b) {
	if (b.digits.size() == 0) out << 0;
	else {
		std::string str = b.toString();
		out << str;
	}
	return out;
}
std::istream& operator>>(std::istream& in, BigInteger& b) {
	char c;
	std::string str;
	while (in.read(&c, 1)) {
		if (c == ' ' || c == '\0' || c == '\n') break;
		str += c;
	}
	b.digits.clear();
	if (str.length() == 0)
		b.sign = false;
	else
	{
		if (str[0] == '-') {
			b.sign = true;
			str = str.substr(1);
		}
		else b.sign = false;
		for (long long i = str.length(); i > 0; i -= 4) {
			if (i < 4)
				b.digits.push_back(atoi(str.substr(0, i).c_str()));
			else
				b.digits.push_back(atoi(str.substr(i - 4, 4).c_str()));
		}
	}
	while (b.digits.size() > 1 && b.digits.back() == 0) {
		b.digits.pop_back();
	}
	if (b.digits.size() == 1 && b.digits[0] == 0) b.sign = false;
	return in;
}

//-------------------------ПРЕОБРАЗОВАНИЯ-----------------------------------------------------------------------------
BigInteger::operator std::string() {
	std::string s = "";
	if (digits.size() == 0) s += '0';
	else {
		if (sign) s += '-';
		for (int i = digits.size() - 1; i >= 0; --i) {
			if (i != static_cast<int>(digits.size()) - 1 && digits[i] / 1000 == 0) {
				if (digits[i] == 0) {
					s += "0000";
					continue;
				}
				int temp = digits[i];
				int sum = 0;
				while (temp != 0) {
					sum++;
					temp /= 10;
				}
				sum = log(base) - sum;
				while (sum != 0) {
					s += '0';
					sum--;
				}
				std::string t = std::to_string(digits[i]);
				s += t;
			}
			else {
				std::string temp = std::to_string(digits[i]);
				s += temp;
			}
		}
	}
	return s;
}
BigInteger::operator bool() {
	return (*this != 0);
}


//-------------------------ОПЕРАТОРЫ BI-------------------------------------------------------------------------------
BigInteger operator""_bi(const char* x) {
	return BigInteger(x);
}
BigInteger operator""_bi(unsigned long long int x) {
	return BigInteger(x);
}
BigInteger operator""_bi(char x) {
	return BigInteger(x);
}
//--------------------------------------------------------------------------------------------------------------------
std::vector<std::vector<long long>> Binary(std::vector<std::vector<long long>> v, int n, int mod, long long step) {
	std::vector<std::vector<long long>> res(step, std::vector<long long>(step, 0));
	for (int i = 0; i < step; i++) {
		for (int j = 0; j < step; j++) {
			for (int k = 0; k < step; k++) {
				res[i][j] += (v[i][k] * v[k][j]) % mod;
				res[i][j] %= mod;
			}
		}
	}
	return res;
}

std::vector<std::vector<long long>> make_OK_copy(long long n, long long step) {
	std::vector<std::vector<long long>> ok_copy(step, std::vector<long long>(step, 0));
	for (long long i = 0; i < step; i++) {
		for (long long j = 0; j < step; j++) {
			long long flag = 1;
			for (int pos = 0; pos < n - 1; pos++) {
				if ((i >> pos & 1) == (j >> pos & 1) && (i >> pos & 1) == (i >> (pos + 1) & 1) && (i >> (pos + 1) & 1) == (j >> (pos + 1) & 1)) { // лучше разбить на несколько условий
					flag = 0;
				}
				if (!flag) {
					break;
				}
			}
			ok_copy[i][j] = flag;
		}
	}
	return ok_copy;
}

std::vector<std::vector<long long>> make_OK(long long step) {
	std::vector<std::vector<long long>> ok(step, std::vector<long long>(step, 0));
	for (int i = 0; i < step; i++) {
		for (int j = 0; j < step; j++) {
			if (i == j) {
				ok[i][j] = 1;
			}
		}
	}
	return ok;
}

long long main_work(int n, BigInteger& m, long long step, std::vector<std::vector<long long>>& ok, std::vector<std::vector<long long>>& ok_copy, long long mod) {
	--m;
	while (m) {
		if (!m.is_even()) {
			std::vector<std::vector<long long>> res(step, std::vector<long long>(step, 0));
			for (int i = 0; i < step; i++) {
				for (int j = 0; j < step; j++) {
					for (int k = 0; k < step; k++) {
						res[i][j] += (ok[i][k] * ok_copy[k][j]) % mod;
						res[i][j] %= mod;
					}
				}
			}
			ok = res;
		}
		m /= 2;
		if (m == 0) {
			break;
		}
		ok_copy = Binary(ok_copy, n, mod, step);
	}


	long long res = 0;
	for (int i = 0; i < pow(2, n); i++) {
		for (int j = 0; j < pow(2, n); j++) {
			res += ok[i][j];
			res %= mod;
		}
	}
	return res;
}

int main()
{
	BigInteger m;
	int n;
	int mod;
	std::cin >> m >> n >> mod;
	long long step = pow(2, n);
	std::vector<std::vector<long long>> ok_copy = make_OK_copy(n, step);
	std::vector<std::vector<long long>> ok = make_OK(step);
	
	std::cout << main_work(n, m, step, ok, ok_copy, mod);
	return 0;
}
